version: 0.1
component: build
timeoutInSeconds: 1200
shell: bash

env:
  variables:
    REGISTRY: "mx-queretaro-1.ocir.io"
    NAMESPACE: "axfvmmw9g9lu"
    REPOSITORY: "taskmanager"
    IMAGE_NAME: "file-service"

  exportedVariables:
    - IMAGE_FULL_NAME
    - VERSION

steps:
  - type: Command
    name: "Install Java 17 - Alternative Method"
    timeoutInSeconds: 600
    command: |
      echo "üîß Installing Java 17 using alternative method..."
      
      cd /opt
      wget -q https://corretto.aws/downloads/latest/amazon-corretto-17-x64-linux-jdk.tar.gz
      tar -xzf amazon-corretto-17-x64-linux-jdk.tar.gz
      
      JAVA17_DIR=$(find /opt -maxdepth 1 -name "amazon-corretto-17*" -type d | head -1)
      echo "Java 17 directory: $JAVA17_DIR"
      
      ln -sf "$JAVA17_DIR" /opt/java17
      echo "‚úÖ Java 17 installed successfully"

  - type: Command
    name: "Recreate wallet files from secrets - Enhanced JKS handling"
    timeoutInSeconds: 300
    command: |
      mkdir -p wallet oci-keys
      
      # Funci√≥n mejorada espec√≠ficamente para archivos JKS
      get_secret_enhanced() {
        local secret_id=$1
        local output_file=$2
        local is_double_encoded=${3:-false}
        local file_type=${4:-"text"}  # "jks", "binary", "text"
      
        echo "üîê Getting secret for: $(basename $output_file) (type: $file_type)"
      
        local content=$(oci secrets secret-bundle get --secret-id "$secret_id" --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$content" ]; then
          echo "‚ùå Failed to get secret $secret_id"
          return 1
        fi
      
        echo "üîç Raw content length: ${#content} chars"
      
        # Primera decodificaci√≥n (siempre necesaria por OCI Vault)
        local decoded_once
        if ! decoded_once=$(echo "$content" | base64 -d 2>/dev/null); then
          echo "‚ùå Failed first base64 decode for $(basename $output_file)"
          return 1
        fi
      
        echo "üîç After first decode length: ${#decoded_once} chars"
      
        # Para archivos JKS, necesitamos manejo especial
        if [ "$file_type" = "jks" ]; then
          echo "üîß Special JKS handling..."
      
          # Intentar m√∫ltiples m√©todos de decodificaci√≥n
          local final_content=""
      
          if [ "$is_double_encoded" = true ]; then
            echo "üîÑ Trying double base64 decode..."
            if final_content=$(echo "$decoded_once" | base64 -d 2>/dev/null); then
              echo "‚úÖ Double decode successful"
            else
              echo "‚ö†Ô∏è Double decode failed, trying single decode"
              final_content="$decoded_once"
            fi
          else
            final_content="$decoded_once"
          fi
      
          # Escribir usando printf para mantener bytes exactos
          printf '%s' "$final_content" > "$output_file"
      
          # Verificaci√≥n espec√≠fica para JKS
          local file_size=$(wc -c < "$output_file")
          echo "üìè JKS file size: $file_size bytes"
      
          if [ "$file_size" -gt 0 ]; then
            # Verificar magic number de JKS (0xFEEDFEED)
            local jks_signature=$(hexdump -C "$output_file" | head -1 | cut -d' ' -f2-5 | tr -d ' ')
            echo "üîç JKS hex signature: $jks_signature"
      
            if [[ "$jks_signature" == "feedfeed"* ]] || [[ "$jks_signature" == "FEEDFEED"* ]]; then
              echo "‚úÖ Valid JKS signature detected"
            else
              echo "‚ö†Ô∏è Invalid JKS signature, trying alternative decode methods..."
      
              # Intentar decodificaci√≥n directa sin base64
              echo "$content" > "$output_file.raw"
              if hexdump -C "$output_file.raw" | head -1 | grep -q "feedfeed\|FEEDFEED"; then
                echo "‚úÖ Raw content is valid JKS"
                mv "$output_file.raw" "$output_file"
              else
                rm -f "$output_file.raw"
                echo "‚ùå Unable to get valid JKS format"
              fi
            fi
          fi
      
        else
          # Manejo normal para otros tipos de archivo
          if [ "$is_double_encoded" = true ]; then
            echo "üîÑ Applying second base64 decode..."
            if decoded_twice=$(echo "$decoded_once" | base64 -d 2>/dev/null); then
              echo "$decoded_twice" > "$output_file"
              echo "‚úÖ Double-decoded successfully"
            else
              echo "‚ö†Ô∏è Second decode failed, using single decode"
              echo "$decoded_once" > "$output_file"
            fi
          else
            echo "$decoded_once" > "$output_file"
            echo "‚úÖ Single-decoded successfully"
          fi
        fi
      
        local final_size=$(wc -c < "$output_file")
        echo "üìè Final file size: $final_size bytes"
      
        return 0
      }
      
      echo "üîê Processing wallet secrets with enhanced JKS handling..."
      
      # Archivos de texto plano (single decode)
      get_secret_enhanced "$WALLET_TNSNAMES_ORA_OCID" "wallet/tnsnames.ora" false "text" || true
      get_secret_enhanced "$WALLET_SQLNET_ORA_OCID" "wallet/sqlnet.ora" false "text" || true  
      get_secret_enhanced "$WALLET_OJDBC_PROPERTIES_OCID" "wallet/ojdbc.properties" false "text" || true
      get_secret_enhanced "$WALLET_EWALLET_PEM_OCID" "wallet/ewallet.pem" false "text" || true
      get_secret_enhanced "$OBJECT_STORAGE_PRIVATE_KEY_OCID" "oci-keys/oci-private-key.pem" false "text" || true
      
      # Archivos binarios (double decode)
      get_secret_enhanced "$WALLET_CWALLET_SSO_OCID" "wallet/cwallet.sso" true "binary" || true
      get_secret_enhanced "$WALLET_EWALLET_P12_OCID" "wallet/ewallet.p12" true "binary" || true
      
      # Archivos JKS con manejo especial
      get_secret_enhanced "$WALLET_KEYSTORE_JKS_OCID" "wallet/keystore.jks" true "jks" || true
      get_secret_enhanced "$WALLET_TRUSTSTORE_JKS_OCID" "wallet/truststore.jks" true "jks" || true
      
      # Configurar permisos
      chmod 600 wallet/* oci-keys/* 2>/dev/null || true
      
      echo "‚úÖ Enhanced wallet processing completed"
      echo "üìã Final wallet verification:"
      
      for file in wallet/keystore.jks wallet/truststore.jks wallet/cwallet.sso; do
        if [ -f "$file" ]; then
          size=$(wc -c < "$file")
          echo "üìÑ $file: ${size} bytes"
      
          if [ "$size" -gt 0 ]; then
            # Mostrar hexdump de los primeros bytes
            echo "   üîç Hex dump (first 16 bytes):"
            hexdump -C "$file" | head -1 || echo "   ‚ùå Cannot read hex dump"
      
            # Para JKS, verificar estructura
            if [[ "$file" == *.jks ]]; then
              if file "$file" | grep -q "Java KeyStore\|data"; then
                echo "   ‚úÖ File type verification passed"
              else
                echo "   ‚ö†Ô∏è File type verification failed: $(file "$file")"
              fi
            fi
          else
            echo "   ‚ùå File is empty!"
          fi
        else
          echo "‚ùå $file: MISSING!"
        fi
      done
      
      echo "üîç sqlnet.ora content:"
      cat wallet/sqlnet.ora 2>/dev/null || echo "‚ùå Cannot read sqlnet.ora"

  - type: Command
    name: "Modify application.properties"
    timeoutInSeconds: 60
    command: |
      if [ -f "src/main/resources/application.properties" ]; then
        echo "üîß Modifying application.properties..."
      
        sed -i 's|TNS_ADMIN=C:/Users/cesar/Wallet_TelegramBotDatabase|TNS_ADMIN=/wallet|g' src/main/resources/application.properties
        sed -i 's|oci.private-key-path=${OCI_PRIVATE_KEY_PATH:C:/Users/cesar/ObjectStorageKeys/a01281202@tec.mx_2025-03-22T10_08_12.916Z.pem}|oci.private-key-path=/oci-keys/oci-private-key.pem|g' src/main/resources/application.properties
      
        echo "‚úÖ application.properties modified"
        echo "üìã Current application.properties:"
        cat src/main/resources/application.properties
      fi

  - type: Command
    name: "Build with Maven using Java 17"
    timeoutInSeconds: 600
    command: |
      export JAVA_HOME=/opt/java17
      export PATH=$JAVA_HOME/bin:$PATH
      
      echo "‚òï Verifying Java installation:"
      java -version
      javac -version
      
      echo "üöÄ Building with Maven..."
      mvn clean package -DskipTests
      
      echo "üì¶ Build completed, checking results:"
      ls -la target/
      
      if [ ! -f "target/FileService-0.0.1-SNAPSHOT.jar" ]; then
        echo "‚ùå JAR file not found!"
        exit 1
      fi
      
      JAR_SIZE=$(stat -c%s "target/FileService-0.0.1-SNAPSHOT.jar" 2>/dev/null || stat -f%z "target/FileService-0.0.1-SNAPSHOT.jar")
      echo "üì¶ JAR size: $JAR_SIZE bytes"
      
      echo "‚úÖ Maven build successful!"

  - type: Command
    name: "Prepare Docker build with wallet validation"
    timeoutInSeconds: 120
    command: |
      mkdir -p build build/wallet build/oci-keys
      
      echo "üì¶ Copying JAR to build directory..."
      cp target/FileService-0.0.1-SNAPSHOT.jar build/
      
      echo "üìÅ Copying wallet and keys..."
      cp -r wallet/* build/wallet/ 2>/dev/null || true
      cp -r oci-keys/* build/oci-keys/ 2>/dev/null || true
      
      echo "üîç Validating wallet files before Docker build:"
      for file in build/wallet/keystore.jks build/wallet/truststore.jks; do
        if [ -f "$file" ]; then
          size=$(wc -c < "$file")
          if [ "$size" -gt 0 ]; then
            echo "‚úÖ $file: ${size} bytes"
            # Test with keytool if available
            if command -v keytool >/dev/null 2>&1; then
              if keytool -list -keystore "$file" -storepass changeit >/dev/null 2>&1; then
                echo "   ‚úÖ JKS structure valid"
              else
                echo "   ‚ö†Ô∏è JKS structure may have issues (this might be OK if password is different)"
              fi
            fi
          else
            echo "‚ùå $file is empty - this will cause issues!"
          fi
        else
          echo "‚ùå $file missing!"
        fi
      done
      
      echo "üê≥ Creating enhanced Dockerfile..."
      cat > Dockerfile << 'EOF'
      FROM container-registry.oracle.com/graalvm/jdk:17
      
      WORKDIR /app
      
      # Install debugging tools
      RUN microdnf install -y file hexdump
      
      RUN mkdir -p /wallet /oci-keys
      
      COPY build/FileService-0.0.1-SNAPSHOT.jar /app/app.jar
      COPY build/wallet/ /wallet/
      COPY build/oci-keys/ /oci-keys/
      
      RUN chmod 755 /app/app.jar
      RUN chmod 600 /wallet/* /oci-keys/* 2>/dev/null || true
      
      # Variables de entorno Oracle mejoradas
      ENV TNS_ADMIN=/wallet
      ENV ORACLE_HOME=/wallet
      ENV LD_LIBRARY_PATH=/wallet
      ENV OCI_PRIVATE_KEY_PATH=/oci-keys/oci-private-key.pem
      
      # Verificaciones exhaustivas en build time
      RUN echo "=== COMPREHENSIVE WALLET DEBUG ===" && \
      ls -la /wallet/ && \
      echo "=== FILE TYPES ===" && \
      file /wallet/* && \
      echo "=== JKS FILES VERIFICATION ===" && \
      for jks in /wallet/*.jks; do \
      if [ -f "$jks" ]; then \
      echo "Checking $jks:"; \
    echo "  Size: $(wc -c < "$jks") bytes"; \
    echo "  Hex signature: $(hexdump -C "$jks" | head -1)"; \
      fi; \
      done && \
      echo "=== SQLNET.ORA CONTENT ===" && \
      cat /wallet/sqlnet.ora 2>/dev/null || echo "sqlnet.ora not found" && \
      echo "=== TNSNAMES.ORA CONTENT (first 5 lines) ===" && \
      head -5 /wallet/tnsnames.ora 2>/dev/null || echo "tnsnames.ora not found"
      
      EXPOSE 8082
      
      # Comando de inicio mejorado con m√°s informaci√≥n de debug
      ENTRYPOINT ["java", "-Djava.security.egd=file:/dev/./urandom", "-Doracle.net.wallet_location=/wallet", "-Doracle.net.tns_admin=/wallet", "-Djavax.net.debug=ssl", "-jar", "/app/app.jar"]
      EOF
      
      echo "‚úÖ Docker build context prepared with enhanced validation"

  - type: Command
    name: "Build and Push Docker image"
    timeoutInSeconds: 900
    command: |
      VERSION="$(date +'%Y%m%d-%H%M%S')"
      if [ -d ".git" ]; then
        COMMIT_SHORT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        VERSION="${VERSION}-${COMMIT_SHORT}"
      fi
      
      IMAGE_TAG="${REGISTRY}/${NAMESPACE}/${REPOSITORY}/${IMAGE_NAME}:${VERSION}"
      echo "üê≥ Building Docker image: ${IMAGE_TAG}"
      
      # Obtener auth token
      echo "üîê Getting auth token from OCI Vault..."
      AUTH_TOKEN=$(oci secrets secret-bundle get --secret-id "$AUTH_TOKEN_OCID" --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
      
      if [ $? -ne 0 ] || [ -z "$AUTH_TOKEN" ]; then
        echo "‚ùå Failed to get auth token from vault"
        exit 1
      fi
      
      DECODED_TOKEN=$(echo "$AUTH_TOKEN" | base64 -d 2>/dev/null)
      if [ $? -eq 0 ] && [ ! -z "$DECODED_TOKEN" ]; then
        AUTH_TOKEN="$DECODED_TOKEN"
      fi
      
      DOCKER_USERNAME="${NAMESPACE}/a01281202@tec.mx"
      
      echo "üîê Logging into Oracle Container Registry..."
      echo "${AUTH_TOKEN}" | docker login ${REGISTRY} -u "${DOCKER_USERNAME}" --password-stdin
      
      if [ $? -ne 0 ]; then
        echo "‚ùå Failed to login to Oracle Container Registry"
        exit 1
      fi
      
      echo "üöÄ Starting Docker build..."
      docker build --no-cache -t "${IMAGE_TAG}" .
      
      if [ $? -ne 0 ]; then
        echo "‚ùå Docker build failed"
        exit 1
      fi
      
      echo "‚úÖ Docker image built successfully!"
      
      export IMAGE_FULL_NAME="${IMAGE_TAG}"
      export VERSION="${VERSION}"

outputArtifacts:
  - name: file-service-image
    type: DOCKER_IMAGE
    location: ${IMAGE_FULL_NAME}