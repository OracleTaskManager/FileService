version: 0.1
component: build
timeoutInSeconds: 1200
shell: bash

env:
  variables:
    REGISTRY: "mx-queretaro-1.ocir.io"
    NAMESPACE: "axfvmmw9g9lu"
    REPOSITORY: "taskmanager"
    IMAGE_NAME: "file-service"

  exportedVariables:
    - IMAGE_FULL_NAME
    - VERSION

steps:
  - type: Command
    name: "Install Java 17 - Alternative Method"
    timeoutInSeconds: 600
    command: |
      echo "üîß Installing Java 17 using alternative method..."
      
      # M√©todo 1: Usar Amazon Corretto (m√°s confiable que OpenJDK en Oracle Linux)
      cd /opt
      wget -q https://corretto.aws/downloads/latest/amazon-corretto-17-x64-linux-jdk.tar.gz
      tar -xzf amazon-corretto-17-x64-linux-jdk.tar.gz
      
      # Encontrar el directorio correcto
      JAVA17_DIR=$(find /opt -maxdepth 1 -name "amazon-corretto-17*" -type d | head -1)
      echo "Java 17 directory: $JAVA17_DIR"
      
      # Crear symlink para f√°cil acceso
      ln -sf "$JAVA17_DIR" /opt/java17
      
      echo "‚úÖ Java 17 installed successfully"

  - type: Command
    name: "Recreate wallet files from secrets"
    timeoutInSeconds: 300
    command: |
      # Usar funci√≥n mejorada para obtener secrets con validaci√≥n espec√≠fica
      mkdir -p wallet oci-keys

  - type: Command
    name: "Recreate wallet files from secrets"
    timeoutInSeconds: 300
    command: |
      # Funci√≥n inteligente para obtener secrets con detecci√≥n autom√°tica de encoding
      mkdir -p wallet oci-keys
      
      get_secret() {
        local secret_id=$1
        local output_file=$2
        local is_double_encoded=${3:-false}  # true para archivos _B64
      
        echo "Getting secret for: $(basename $output_file)"
      
        local content=$(oci secrets secret-bundle get --secret-id "$secret_id" --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$content" ]; then
          echo "‚ùå Failed to get secret $secret_id"
          touch "$output_file"
          return 1
        fi
      
        echo "üîç Raw content length: ${#content} chars"
      
        # Primera decodificaci√≥n (siempre necesaria por OCI Vault)
        local decoded_once=$(echo "$content" | base64 -d 2>/dev/null)
        if [ $? -ne 0 ]; then
          echo "‚ùå Failed first base64 decode for $(basename $output_file)"
          echo "$content" > "$output_file"
          return 1
        fi
      
        echo "üîç After first decode length: ${#decoded_once} chars"
      
        # Si es archivo con doble encoding (_B64), decodificar otra vez
        if [ "$is_double_encoded" = true ]; then
          echo "üîÑ Applying second base64 decode for _B64 file..."
          local decoded_twice=$(echo "$decoded_once" | base64 -d 2>/dev/null)
          if [ $? -eq 0 ] && [ ! -z "$decoded_twice" ]; then
            echo "$decoded_twice" > "$output_file"
            echo "‚úÖ Double-decoded successfully for $(basename $output_file)"
          else
            echo "‚ö†Ô∏è Second decode failed, using single decode for $(basename $output_file)"
            echo "$decoded_once" > "$output_file"
          fi
        else
          # Single decode para archivos plaintext
          echo "$decoded_once" > "$output_file"
          echo "‚úÖ Single-decoded successfully for $(basename $output_file)"
        fi
      
        # Verificaciones espec√≠ficas por tipo
        local file_size=$(wc -c < "$output_file")
        echo "üìè Final file size: $file_size bytes"
      
        if [ "$file_size" -eq 0 ]; then
          echo "‚ùå WARNING: $(basename $output_file) is empty!"
          return 1
        fi
      
        # Verificar archivos JKS
        if [[ "$output_file" == *.jks ]]; then
          local file_signature=$(xxd -l 4 -p "$output_file" 2>/dev/null | tr '[:lower:]' '[:upper:]')
          if [[ "$file_signature" == "FEEDFEED" ]]; then
            echo "‚úÖ JKS signature verified for $(basename $output_file)"
          else
            echo "‚ö†Ô∏è WARNING: Invalid JKS signature ($file_signature) for $(basename $output_file)"
          fi
        fi
      
        return 0
      }
      
      echo "üîê Processing wallet secrets with correct encoding..."
      
      # Archivos guardados como PLAINTEXT (single decode)
      get_secret "$WALLET_TNSNAMES_ORA_OCID" "wallet/tnsnames.ora" false || true
      get_secret "$WALLET_SQLNET_ORA_OCID" "wallet/sqlnet.ora" false || true  
      get_secret "$WALLET_OJDBC_PROPERTIES_OCID" "wallet/ojdbc.properties" false || true
      get_secret "$WALLET_EWALLET_PEM_OCID" "wallet/ewallet.pem" false || true
      get_secret "$OBJECT_STORAGE_PRIVATE_KEY_OCID" "oci-keys/oci-private-key.pem" false || true
      
      # Archivos guardados como BASE64 primero (double decode) 
      get_secret "$WALLET_CWALLET_SSO_OCID" "wallet/cwallet.sso" true || true
      get_secret "$WALLET_KEYSTORE_JKS_OCID" "wallet/keystore.jks" true || true
      get_secret "$WALLET_TRUSTSTORE_JKS_OCID" "wallet/truststore.jks" true || true
      get_secret "$WALLET_EWALLET_P12_OCID" "wallet/ewallet.p12" true || true
      
      # README - asumir plaintext si existe
      if [ ! -z "$WALLET_README_OCID" ]; then
        get_secret "$WALLET_README_OCID" "wallet/README" false || true
      fi
      
      # Configurar permisos
      chmod 600 wallet/* oci-keys/* 2>/dev/null || true
      
      echo "‚úÖ Wallet processing completed"
      echo "üìã Final wallet contents:"
      ls -la wallet/ oci-keys/
      
      # Verificar archivos cr√≠ticos con informaci√≥n detallada
      echo "üîç Final verification:"
      for file in wallet/keystore.jks wallet/truststore.jks wallet/cwallet.sso wallet/tnsnames.ora; do
        if [ -f "$file" ]; then
          size=$(wc -c < "$file")
          if [ "$size" -gt 0 ]; then
            echo "‚úÖ $file: ${size} bytes"
            # Para archivos cr√≠ticos, mostrar los primeros bytes en hex
            if [[ "$file" == *".jks" ]] || [[ "$file" == *".sso" ]]; then
              signature=$(xxd -l 8 -p "$file" 2>/dev/null | tr '[:lower:]' '[:upper:]')
              echo "   üìã File signature: $signature"
            fi
          else
            echo "‚ùå $file: EMPTY!"
          fi
        else
          echo "‚ùå $file: MISSING!"
        fi
      done
      
      # Verificar permisos y propietario
      echo "üîç Wallet permissions and ownership:"
      ls -la wallet/
      
      # Verificar que sqlnet.ora apunte al directorio correcto
      echo "üîç Checking sqlnet.ora content:"
      if [ -f "wallet/sqlnet.ora" ]; then
        cat wallet/sqlnet.ora
      else
        echo "‚ùå sqlnet.ora not found!"
      fi

  - type: Command
    name: "Modify application.properties"
    timeoutInSeconds: 60
    command: |
      # Usar exactamente el mismo c√≥digo de GitHub Actions
      if [ -f "src/main/resources/application.properties" ]; then
        echo "üîß Modifying application.properties..."
      
        sed -i 's|TNS_ADMIN=C:/Users/cesar/Wallet_TelegramBotDatabase|TNS_ADMIN=/wallet|g' src/main/resources/application.properties
        sed -i 's|oci.private-key-path=${OCI_PRIVATE_KEY_PATH:C:/Users/cesar/ObjectStorageKeys/a01281202@tec.mx_2025-03-22T10_08_12.916Z.pem}|oci.private-key-path=/oci-keys/oci-private-key.pem|g' src/main/resources/application.properties
      
        echo "‚úÖ application.properties modified"
        cat src/main/resources/application.properties
      fi

  - type: Command
    name: "Build with Maven using Java 17"
    timeoutInSeconds: 600
    command: |
      # Configurar Java 17 de forma robusta
      export JAVA_HOME=/opt/java17
      export PATH=$JAVA_HOME/bin:$PATH
      
      echo "‚òï Verifying Java installation:"
      java -version
      javac -version
      echo "üîß JAVA_HOME: $JAVA_HOME"
      echo "üîß PATH: $PATH"
      
      echo "üìã Maven version:"
      mvn -version
      
      echo "üöÄ Building with Maven (same as GitHub Actions)..."
      
      # Usar exactamente el mismo comando que GitHub Actions
      mvn clean package -DskipTests
      
      echo "üì¶ Build completed, checking results:"
      ls -la target/
      
      # Verificaciones adicionales
      if [ ! -f "target/FileService-0.0.1-SNAPSHOT.jar" ]; then
        echo "‚ùå JAR file not found!"
        exit 1
      fi
      
      JAR_SIZE=$(stat -c%s "target/FileService-0.0.1-SNAPSHOT.jar" 2>/dev/null || stat -f%z "target/FileService-0.0.1-SNAPSHOT.jar")
      echo "üì¶ JAR size: $JAR_SIZE bytes"
      
      if [ "$JAR_SIZE" -lt 1000000 ]; then  # Menos de 1MB es sospechoso
        echo "‚ö†Ô∏è JAR seems small for a Spring Boot app"
      fi
      
      echo "‚úÖ Maven build successful!"

  - type: Command
    name: "Prepare Docker build"
    timeoutInSeconds: 120
    command: |
      # Usar exactamente la misma estructura que GitHub Actions
      mkdir -p build build/wallet build/oci-keys
      
      echo "Copying JAR to build directory..."
      cp target/FileService-0.0.1-SNAPSHOT.jar build/
      
      echo "Copying wallet and keys..."
      cp -r wallet/* build/wallet/ 2>/dev/null || true
      cp -r oci-keys/* build/oci-keys/ 2>/dev/null || true
      
      echo "Creating Dockerfile (using GraalVM from Oracle registry)..."
      cat > Dockerfile << 'EOF'
      FROM container-registry.oracle.com/graalvm/jdk:17
    
      WORKDIR /app
      
      RUN mkdir -p /wallet /oci-keys
      
      COPY build/FileService-0.0.1-SNAPSHOT.jar /app/app.jar
      COPY build/wallet/ /wallet/
      COPY build/oci-keys/ /oci-keys/
      
      RUN chmod 755 /app/app.jar
      RUN chmod 600 /wallet/* /oci-keys/* 2>/dev/null || true
      
      # Variables de entorno Oracle
      ENV TNS_ADMIN=/wallet
      ENV ORACLE_HOME=/wallet
      ENV LD_LIBRARY_PATH=/wallet
      ENV OCI_PRIVATE_KEY_PATH=/oci-keys/oci-private-key.pem
      
      # Debug: Verificar que los archivos est√©n presentes
      RUN echo "=== WALLET DEBUG ===" && \
      ls -la /wallet/ && \
      echo "=== WALLET FILES CONTENT CHECK ===" && \
      file /wallet/* && \
      echo "=== SQLNET.ORA CONTENT ===" && \
      cat /wallet/sqlnet.ora 2>/dev/null || echo "sqlnet.ora not found" && \
      echo "=== TNSNAMES.ORA CONTENT ===" && \
      head -5 /wallet/tnsnames.ora 2>/dev/null || echo "tnsnames.ora not found"
      
      EXPOSE 8082
      
      ENTRYPOINT ["java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/app.jar"]
      EOF
      
      echo "‚úÖ Docker build context prepared"
      ls -la build/

  - type: Command
    name: "Build and Push Docker image"
    timeoutInSeconds: 900
    command: |
      # Generar versi√≥n
      VERSION="$(date +'%Y%m%d-%H%M%S')"
      if [ -d ".git" ]; then
        COMMIT_SHORT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        VERSION="${VERSION}-${COMMIT_SHORT}"
      fi
      
      IMAGE_TAG="${REGISTRY}/${NAMESPACE}/${REPOSITORY}/${IMAGE_NAME}:${VERSION}"
      echo "üê≥ Building Docker image: ${IMAGE_TAG}"
      
      # Debug: Mostrar informaci√≥n de las variables
      echo "üîç DEBUG - Login Information:"
      echo "REGISTRY: ${REGISTRY}"
      echo "NAMESPACE: ${NAMESPACE}"
      
      # Verificar que tenemos las credenciales necesarias
      if [ -z "$AUTH_TOKEN_OCID" ]; then
        echo "‚ùå AUTH_TOKEN_OCID not found. Please configure it in the build variables."
        exit 1
      else
        echo "‚úÖ AUTH_TOKEN_OCID is present: ${AUTH_TOKEN_OCID}"
      fi
      
      # Obtener el token real del vault (igual que los wallet files)
      echo "üîê Getting auth token from OCI Vault..."
      AUTH_TOKEN=$(oci secrets secret-bundle get --secret-id "$AUTH_TOKEN_OCID" --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
      
      if [ $? -ne 0 ] || [ -z "$AUTH_TOKEN" ]; then
        echo "‚ùå Failed to get auth token from vault"
        exit 1
      fi
      
      # Intentar decodificar base64 si es necesario
      DECODED_TOKEN=$(echo "$AUTH_TOKEN" | base64 -d 2>/dev/null)
      if [ $? -eq 0 ] && [ ! -z "$DECODED_TOKEN" ]; then
        AUTH_TOKEN="$DECODED_TOKEN"
        echo "‚úÖ Auth token decoded from base64"
      else
        echo "‚úÖ Using auth token as-is (not base64 encoded)"
      fi
      
      echo "üîç Auth token length: ${#AUTH_TOKEN} characters"
      echo "üîç Auth token first 10 chars: ${AUTH_TOKEN:0:10}..."
      
      # Construir username para login
      DOCKER_USERNAME="${NAMESPACE}/a01281202@tec.mx"
      echo "üîç Attempting login with username: ${DOCKER_USERNAME}"
      
      echo "üîê Logging into Docker registries..."
      
      # Login a Oracle Container Registry (ya no necesitamos Docker Hub)
      echo "Logging into Oracle Container Registry..."
      echo "Registry URL: ${REGISTRY}"
      echo "${AUTH_TOKEN}" | docker login ${REGISTRY} -u "${DOCKER_USERNAME}" --password-stdin 2>&1
      ocr_login_result=$?
      
      if [ $ocr_login_result -eq 0 ]; then
        echo "‚úÖ Successfully logged into Oracle Container Registry"
      else
        echo "‚ùå Failed to login to Oracle Container Registry (exit code: $ocr_login_result)"
        echo "This will cause issues pushing the final image"
        exit 1
      fi
      
      # Mostrar el Dockerfile que vamos a usar
      echo "üìã Current Dockerfile (first 5 lines):"
      head -5 Dockerfile
      
      # Intentar el build
      echo "üöÄ Starting Docker build..."
      docker build --no-cache -t "${IMAGE_TAG}" .
      build_result=$?
      
      if [ $build_result -ne 0 ]; then
        echo "‚ùå Docker build failed, exit code: $build_result"
        exit 1
      fi
      
      echo "‚úÖ Docker image built successfully!"
      echo "üè∑Ô∏è Image tagged as: ${IMAGE_TAG}"
      
      # Exportar variables para el siguiente stage
      export IMAGE_FULL_NAME="${IMAGE_TAG}"
      export VERSION="${VERSION}"
      
      echo "üéØ IMAGE_FULL_NAME=${IMAGE_FULL_NAME}"
      echo "üéØ VERSION=${VERSION}"

outputArtifacts:
  - name: file-service-image
    type: DOCKER_IMAGE
    location: ${IMAGE_FULL_NAME}