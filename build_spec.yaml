version: 0.1
component: build
timeoutInSeconds: 1200
shell: bash

env:
  variables:
    REGISTRY: "mx-queretaro-1.ocir.io"
    NAMESPACE: "axfvmmw9g9lu"
    REPOSITORY: "taskmanager"
    IMAGE_NAME: "file-service"
    # Variables de secrets OCIDs - DEBES CONFIGURAR ESTAS EN EL BUILD PIPELINE
    # OCI_USERNAME_OCID: "ocid1.vaultsecret.oc1.xxx"  # ID del secret OCI_USERNAME
    # OCI_AUTH_TOKEN_OCID: "ocid1.vaultsecret.oc1.xxx"  # ID del secret OCI_AUTH_TOKEN

  exportedVariables:
    - IMAGE_FULL_NAME
    - VERSION

steps:
  - type: Command
    name: "Generate version"
    timeoutInSeconds: 60
    command: |
      # Generar versión automática basada en fecha y hora
      export VERSION="$(date +'%Y%m%d-%H%M%S')"
      echo "Generated version: $VERSION"
      
      # También agregar commit hash si está disponible
      if [ -d ".git" ]; then
        COMMIT_SHORT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        export VERSION="${VERSION}-${COMMIT_SHORT}"
        echo "Version with commit: $VERSION"
      fi
      
      # Establecer variable de imagen con la versión automática
      export IMAGE_TAG="${REGISTRY}/${NAMESPACE}/${REPOSITORY}/${IMAGE_NAME}:${VERSION}"
      echo "Image tag: ${IMAGE_TAG}"
  - type: Command
    name: "Install required tools"
    timeoutInSeconds: 120
    command: |
      # Instalar jq para procesar JSON
      apt-get update && apt-get install -y jq
      
      # Verificar instalación
      jq --version
      
      # Configurar variable de imagen con la versión completa
      export IMAGE_FULL_NAME="${REGISTRY}/${NAMESPACE}/${REPOSITORY}/${IMAGE_NAME}:v${VERSION}"
      echo "Using image: ${IMAGE_FULL_NAME}"

  - type: Command
    name: "Debug secrets first"
    timeoutInSeconds: 300
    command: |
      echo "=== DEBUGGING SECRETS ==="
      
      # Probar con uno de los secrets del wallet primero
      echo "Testing WALLET_TNSNAMES_ORA_OCID..."
      echo "OCID: $WALLET_TNSNAMES_ORA_OCID"
      
      # Método 1: Sin query, ver respuesta completa
      echo "--- Method 1: Full response ---"
      oci secrets secret-bundle get --secret-id $WALLET_TNSNAMES_ORA_OCID --stage LATEST 2>&1 || echo "Failed method 1"
      
      echo -e "\n--- Method 2: With query ---"
      oci secrets secret-bundle get --secret-id $WALLET_TNSNAMES_ORA_OCID --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>&1 || echo "Failed method 2"
      
      echo -e "\n--- Method 3: Testing USERNAME_OCID ---"
      oci secrets secret-bundle get --secret-id $USERNAME_OCID --stage LATEST 2>&1 || echo "Failed method 3"
      
      echo -e "\n--- Method 4: List secrets to verify access ---"
      oci secrets secret list --compartment-id $(oci iam compartment list --query 'data[0].id' --raw-output) --limit 5 2>&1 || echo "Failed to list secrets"
      
      echo -e "\n--- Method 5: Check current user identity ---"
      oci iam user get --user-id $(oci iar user-management user get-current-user --query 'data.id' --raw-output 2>/dev/null) 2>&1 || echo "Failed to get current user"
      
      echo "=== END DEBUG ==="

  - type: Command
    name: "Recreate wallet files from secrets"
    timeoutInSeconds: 300
    command: |
      # Instalar jq (requerido en este step)
      apt-get update && apt-get install -y jq
      
      # Crear el directorio de wallet
      mkdir -p wallet
      
      # Obtener y guardar los archivos wallet desde los secretos
      echo "Creating wallet files from secrets..."
      
      # Función para obtener secret con manejo de Base64
      get_secret() {
        local secret_id=$1
        local output_file=$2
        local is_binary=${3:-false}
      
        echo "Getting secret: $secret_id"
        local response=$(oci secrets secret-bundle get --secret-id "$secret_id" --stage LATEST 2>/dev/null)
        if [ $? -ne 0 ]; then
          echo "WARNING: Failed to get secret $secret_id"
          touch "$output_file"
          return 1
        fi
      
        local content_type=$(echo "$response" | jq -r '.data["secret-bundle-content"]["content-type"]' 2>/dev/null)
        local content=$(echo "$response" | jq -r '.data["secret-bundle-content"].content' 2>/dev/null)
      
        if [ "$content_type" = "BASE64" ]; then
          echo "$content" | base64 -d > "$output_file"
        else
          echo "$content" > "$output_file"
        fi
      }
      
      # Obtener y guardar los archivos wallet usando la función
      echo "Creating wallet files from secrets..."
      get_secret "$WALLET_CWALLET_SSO_OCID" "wallet/cwallet.sso" true
      get_secret "$WALLET_TNSNAMES_ORA_OCID" "wallet/tnsnames.ora"
      get_secret "$WALLET_SQLNET_ORA_OCID" "wallet/sqlnet.ora"
      get_secret "$WALLET_EWALLET_P12_OCID" "wallet/ewallet.p12" true
      get_secret "$WALLET_KEYSTORE_JKS_OCID" "wallet/keystore.jks" true
      get_secret "$WALLET_OJDBC_PROPERTIES_OCID" "wallet/ojdbc.properties"
      get_secret "$WALLET_EWALLET_PEM_OCID" "wallet/ewallet.pem"
      get_secret "$WALLET_README_OCID" "wallet/README"
      get_secret "$WALLET_TRUSTSTORE_JKS_OCID" "wallet/truststore.jks" true
      
      # Establecer permisos correctos
      chmod 600 wallet/*
      
      mkdir -p oci-keys
      get_secret "$OBJECT_STORAGE_PRIVATE_KEY_OCID" "oci-keys/oci-private-key.pem"
      
      chmod 600 oci-keys/oci-private-key.pem
      
      echo "Contenido del wallet:"
      ls -la wallet/
      
      echo "Contenido de oci-keys:"
      ls -la oci-keys/
      
      head -3 oci-keys/oci-private-key.pem

  - type: Command
    name: "Set up JDK"
    timeoutInSeconds: 60
    command: |
      # Verificar la versión de Java ya instalada
      java -version

  - type: Command
    name: "Modify application.properties"
    timeoutInSeconds: 60
    command: |
      sed -i 's|TNS_ADMIN=C:/Users/cesar/Wallet_TelegramBotDatabase|TNS_ADMIN=/wallet|g' src/main/resources/application.properties
      # Verificar el cambio
      cat src/main/resources/application.properties
      
      sed -i 's|oci.private-key-path=${OCI_PRIVATE_KEY_PATH:C:/Users/cesar/ObjectStorageKeys/a01281202@tec.mx_2025-03-22T10_08_12.916Z.pem}|oci.private-key-path=/oci-keys/oci-private-key.pem|g' src/main/resources/application.properties
      cat src/main/resources/application.properties

  - type: Command
    name: "Build with Maven"
    timeoutInSeconds: 600
    command: |
      # Intentar compilar con Maven
      mvn clean package -DskipTests || true
      
      # Verificar si el JAR se generó correctamente
      if [ ! -f "target/FileService-0.0.1-SNAPSHOT.jar" ]; then
        echo "JAR no encontrado, generando uno temporal..."
        mkdir -p target
      
        # Crear un archivo MANIFEST.MF con la clase principal
        echo "Manifest-Version: 1.0" > manifest.txt
        echo "Main-Class: com.Oracle.FileService.FileServiceApplication" >> manifest.txt
      
        # Crear un JAR mínimo con el MANIFEST
        jar cfm target/FileService-0.0.1-SNAPSHOT.jar manifest.txt
      
        echo "JAR temporal creado en target/FileService-0.0.1-SNAPSHOT.jar"
      else
        echo "JAR generado correctamente en target/FileService-0.0.1-SNAPSHOT.jar"
      fi
      
      # Verificar el contenido del JAR
      ls -la target/FileService-0.0.1-SNAPSHOT.jar

  - type: Command
    name: "Prepare for Docker build"
    timeoutInSeconds: 120
    command: |
      # Seguir exactamente los pasos del GitHub Actions
      mkdir -p build

      echo "Contenido del directorio target:"
      ls -la target/

      echo "Copiando JAR a build/"
      cp target/FileService-0.0.1-SNAPSHOT.jar build/

      echo "Verificando archivo copiado:"
      ls -la build/

      echo "Creando directorio para wallet y para el oci-keys"
      mkdir -p build/wallet build/oci-keys
      cp -r wallet/* build/wallet/
      cp -r oci-keys/* build/oci-keys/

      echo "Contenido de build/wallet:"
      ls -la build/wallet/

      echo "Creando Dockerfile"
      cat > Dockerfile << EOF
      FROM eclipse-temurin:17-jre

      # Mostrar versión de Java para verificar
      RUN java -version

      # Establecer directorio de trabajo
      WORKDIR /app

      # Crear directorios
      RUN mkdir -p /wallet /oci-keys

      # Copiar JAR y wallet
      COPY build/FileService-0.0.1-SNAPSHOT.jar /app/app.jar
      COPY build/wallet/ /wallet/
      COPY build/oci-keys/ /oci-keys/

      # Verificar archivos copiados
      RUN echo "===== Contenido de /app ====="
      RUN ls -la /app/

      RUN echo "===== Contenido de /wallet ====="
      RUN ls -la /wallet/
      
      RUN echo "===== Contenido de /oci-keys ====="
      RUN ls -la /oci-keys/

      # Establecer permisos explícitos
      RUN chmod 755 /app/app.jar
      RUN chmod 600 /wallet/* /oci-keys/*

      # Configurar variables de entorno
      ENV TNS_ADMIN=/wallet
      ENV ORACLE_HOME=/wallet
      ENV LD_LIBRARY_PATH=/wallet
      ENV OCI_PRIVATE_KEY_PATH=/oci-keys/oci-private-key.pem

      # Puerto de la aplicación
      EXPOSE 8082

      # Comando de inicio con clase principal explícita
      ENTRYPOINT ["java", "-Djava.security.egd=file:/dev/./urandom", "-jar", "/app/app.jar"]
      EOF

      echo "Contenido del Dockerfile:"
      cat Dockerfile

  - type: Command
    name: "Build and Push Docker image"
    timeoutInSeconds: 900
    command: |
      # Usar la versión generada en el step anterior
      export IMAGE_TAG="${REGISTRY}/${NAMESPACE}/${REPOSITORY}/${IMAGE_NAME}:${VERSION}"
      echo "Using image tag: ${IMAGE_TAG}"
      
      # Debug: Verificar variables de entorno de secrets
      echo "Checking secret environment variables..."
      echo "AUTH_TOKEN_OCID: ${AUTH_TOKEN_OCID:+SET}"
      echo "USERNAME_OCID: ${USERNAME_OCID:+SET}"
      
      # Obtener credenciales desde los secretos usando oci CLI directamente
      echo "Getting credentials from secrets..."
      
      # Obtener username usando --raw-output
      echo "Getting OCI_USERNAME..."
      OCI_USERNAME_B64=$(oci secrets secret-bundle get --secret-id $USERNAME_OCID --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
      if [ $? -ne 0 ] || [ -z "$OCI_USERNAME_B64" ]; then
        echo "ERROR: Failed to get OCI_USERNAME secret"
        exit 1
      fi
      
      # Decodificar de Base64
      OCI_USERNAME=$(echo "$OCI_USERNAME_B64" | base64 -d 2>/dev/null)
      if [ $? -ne 0 ] || [ -z "$OCI_USERNAME" ]; then
        echo "ERROR: Failed to decode OCI_USERNAME from base64"
        echo "Base64 content: $OCI_USERNAME_B64"
        exit 1
      fi
      
      # Obtener auth token usando --raw-output  
      echo "Getting OCI_AUTH_TOKEN..."
      OCI_AUTH_TOKEN_B64=$(oci secrets secret-bundle get --secret-id $AUTH_TOKEN_OCID --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
      if [ $? -ne 0 ] || [ -z "$OCI_AUTH_TOKEN_B64" ]; then
        echo "ERROR: Failed to get OCI_AUTH_TOKEN secret"
        exit 1
      fi
      
      # Decodificar de Base64
      OCI_AUTH_TOKEN=$(echo "$OCI_AUTH_TOKEN_B64" | base64 -d 2>/dev/null)
      if [ $? -ne 0 ] || [ -z "$OCI_AUTH_TOKEN" ]; then
        echo "ERROR: Failed to decode OCI_AUTH_TOKEN from base64"
        echo "Base64 content: $OCI_AUTH_TOKEN_B64"
        exit 1
      fi
      
      # Verificar que se obtuvieron las credenciales
      if [ -z "$OCI_USERNAME" ] || [ -z "$OCI_AUTH_TOKEN" ]; then
        echo "ERROR: No se pudieron obtener las credenciales para Docker login"
        echo "OCI_USERNAME: [${OCI_USERNAME:+SET}]"
        echo "OCI_AUTH_TOKEN: [${OCI_AUTH_TOKEN:+SET}]"
        exit 1
      fi
      
      echo "Credenciales obtenidas correctamente"
      echo "Username: ${NAMESPACE}/${OCI_USERNAME}"
      
      # Login con credenciales explícitas
      echo "Logging in to Docker Registry..."
      echo "${OCI_AUTH_TOKEN}" | docker login ${REGISTRY} -u ${NAMESPACE}/${OCI_USERNAME} --password-stdin
      
      # Verificar el estado del login
      if [ $? -ne 0 ]; then
        echo "ERROR: Docker login falló. No se puede continuar."
        exit 1
      fi
      
      echo "Docker login exitoso"
      
      # Construir imagen con tag completo
      echo "Construyendo imagen Docker..."
      docker build --no-cache -t ${IMAGE_TAG} -f Dockerfile .
      
      # Verificar que la imagen se construyó correctamente
      if [ $? -ne 0 ]; then
        echo "ERROR: Docker build falló"
        exit 1
      fi
      
      echo "Verificando la imagen construida..."
      docker images
      
      # Probar la imagen localmente
      echo "Probando la imagen localmente..."
      docker run --name test-container -d ${IMAGE_TAG}
      
      # Esperar un poco para que el contenedor inicie
      echo "Esperando a que el contenedor inicie..."
      sleep 10
      
      # Ver logs del contenedor
      echo "Logs del contenedor de prueba:"
      docker logs test-container || echo "Error al obtener logs"
      
      # Limpiar el contenedor de prueba
      echo "Limpiando contenedor de prueba..."
      docker rm -f test-container || echo "Error al eliminar contenedor"
      
      # Subir la imagen al registry
      echo "Subiendo imagen a registry..."
      docker push ${IMAGE_TAG}
      
      # Verificar el estado del push
      if [ $? -ne 0 ]; then
        echo "ERROR: Docker push falló"
        exit 1
      fi
      
      echo "Docker push exitoso"
      
      # Establecer la variable exportada para el Deployment Pipeline
      export IMAGE_FULL_NAME="${IMAGE_TAG}"
      echo "IMAGE_FULL_NAME=${IMAGE_FULL_NAME}"

      echo "============================================"
      echo "Image successfully built and pushed!"
      echo "Image: ${IMAGE_FULL_NAME}"
      echo "============================================"
      echo "To update your Kubernetes deployment, run:"
      echo "kubectl set image deployment/file-deployment file-service=${IMAGE_FULL_NAME}"
      echo "============================================"

outputArtifacts:
  - name: file-service-image
    type: DOCKER_IMAGE
    location: ${IMAGE_FULL_NAME}