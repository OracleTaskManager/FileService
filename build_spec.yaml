version: 0.1
component: build
timeoutInSeconds: 1200
shell: bash

env:
  variables:
    REGISTRY: "mx-queretaro-1.ocir.io"
    NAMESPACE: "axfvmmw9g9lu"
    REPOSITORY: "taskmanager"
    IMAGE_NAME: "file-service"

  exportedVariables:
    - IMAGE_FULL_NAME
    - VERSION

steps:
  - type: Command
    name: "Install Java 17"
    timeoutInSeconds: 600
    command: |
      echo "üîß Installing Java 17..."
      cd /opt
      wget -q https://corretto.aws/downloads/latest/amazon-corretto-17-x64-linux-jdk.tar.gz
      tar -xzf amazon-corretto-17-x64-linux-jdk.tar.gz
      
      JAVA17_DIR=$(find /opt -maxdepth 1 -name "amazon-corretto-17*" -type d | head -1)
      ln -sf "$JAVA17_DIR" /opt/java17
      echo "‚úÖ Java 17 installed successfully"

  - type: Command
    name: "Recreate wallet files - SSO ONLY approach"
    timeoutInSeconds: 300
    command: |
      mkdir -p wallet oci-keys
      
      get_secret() {
        local secret_id=$1
        local output_file=$2
        local is_double_encoded=${3:-false}
      
        echo "Getting secret for: $(basename $output_file)"
      
        local content=$(oci secrets secret-bundle get --secret-id "$secret_id" --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$content" ]; then
          echo "‚ùå Failed to get secret $secret_id"
          return 1
        fi
      
        local decoded_once=$(echo "$content" | base64 -d 2>/dev/null)
        if [ $? -ne 0 ]; then
          echo "‚ùå Failed first base64 decode"
          return 1
        fi
      
        if [ "$is_double_encoded" = true ]; then
          local decoded_twice=$(echo "$decoded_once" | base64 -d 2>/dev/null)
          if [ $? -eq 0 ] && [ ! -z "$decoded_twice" ]; then
            echo "$decoded_twice" > "$output_file"
          else
            echo "$decoded_once" > "$output_file"
          fi
        else
          echo "$decoded_once" > "$output_file"
        fi
      
        local file_size=$(wc -c < "$output_file")
        echo "üìè Final file size: $file_size bytes"
        return 0
      }
      
      echo "üîê Processing wallet secrets (SSO-only approach)..."
      
      # Archivos esenciales
      get_secret "$WALLET_TNSNAMES_ORA_OCID" "wallet/tnsnames.ora" false || true
      get_secret "$WALLET_SQLNET_ORA_OCID" "wallet/sqlnet.ora" false || true  
      get_secret "$WALLET_OJDBC_PROPERTIES_OCID" "wallet/ojdbc.properties" false || true
      get_secret "$OBJECT_STORAGE_PRIVATE_KEY_OCID" "oci-keys/oci-private-key.pem" false || true
      
      # Solo cwallet.sso (que funciona correctamente)
      get_secret "$WALLET_CWALLET_SSO_OCID" "wallet/cwallet.sso" true || true
      
      # IMPORTANTE: Configurar sqlnet.ora para SSO-only
      echo "üîß Configuring sqlnet.ora for SSO-only mode..."
      cat > wallet/sqlnet.ora << 'EOF'
      WALLET_LOCATION = (SOURCE = (METHOD = file) (METHOD_DATA = (DIRECTORY="/wallet")))
      SSL_SERVER_DN_MATCH=yes
      SQLNET.WALLET_OVERRIDE = TRUE
      SSL_CLIENT_AUTHENTICATION = FALSE
      EOF
      
      chmod 600 wallet/* oci-keys/* 2>/dev/null || true
      
      echo "‚úÖ SSO-only wallet processing completed"

  - type: Command
    name: "Verify Wallet Files"
    timeoutInSeconds: 120
    command: |
      echo "üîç Verificando archivos de wallet..."
      
      WALLET_DIR="wallet"
      ERRORS=0
      
      # Funci√≥n para verificar archivos
      verify_file() {
          local file=$1
          local expected_type=$2
          local min_size=${3:-1}
      
          if [ ! -f "$file" ]; then
              echo "‚ùå FALTA: $file"
              ((ERRORS++))
              return 1
          fi
      
          local size=$(wc -c < "$file")
          if [ "$size" -lt "$min_size" ]; then
              echo "‚ùå VAC√çO: $file (${size} bytes)"
              ((ERRORS++))
              return 1
          fi
      
          echo "‚úÖ OK: $file (${size} bytes)"
      
          # Verificaciones espec√≠ficas por tipo
          case "$expected_type" in
              "sso")
                  if file "$file" | grep -q "data"; then
                      echo "   ‚úÖ Archivo SSO v√°lido"
                  else
                      echo "   ‚ö†Ô∏è Archivo SSO puede estar corrupto"
                  fi
                  ;;
              "pem")
                  if grep -q "BEGIN" "$file" && grep -q "END" "$file"; then
                      echo "   ‚úÖ Estructura PEM v√°lida"
                  else
                      echo "   ‚ö†Ô∏è Estructura PEM inv√°lida"
                      ((ERRORS++))
                  fi
                  ;;
          esac
      
          return 0
      }
      
      # Verificar archivos cr√≠ticos
      echo "üìã Verificando archivos cr√≠ticos del wallet..."
      
      verify_file "$WALLET_DIR/tnsnames.ora" "text" 100
      verify_file "$WALLET_DIR/sqlnet.ora" "text" 50
      verify_file "$WALLET_DIR/cwallet.sso" "sso" 1000
      
      if [ -f "oci-keys/oci-private-key.pem" ]; then
          verify_file "oci-keys/oci-private-key.pem" "pem" 1000
      fi
      
      # Verificar configuraci√≥n de sqlnet.ora
      echo ""
      echo "üîß Verificando configuraci√≥n de sqlnet.ora..."
      if [ -f "$WALLET_DIR/sqlnet.ora" ]; then
          echo "Contenido actual:"
          cat "$WALLET_DIR/sqlnet.ora"
      
          if grep -q "WALLET_LOCATION.*wallet" "$WALLET_DIR/sqlnet.ora"; then
              echo "‚úÖ WALLET_LOCATION configurado correctamente"
          else
              echo "‚ùå WALLET_LOCATION no configurado correctamente"
              ((ERRORS++))
          fi
      else
          echo "‚ùå sqlnet.ora no encontrado"
          ((ERRORS++))
      fi
      
      # Resultado final
      echo ""
      echo "===================="
      if [ $ERRORS -eq 0 ]; then
          echo "‚úÖ VERIFICACI√ìN COMPLETA: Wallet parece estar correcto"
      else
          echo "‚ùå VERIFICACI√ìN FALLIDA: $ERRORS errores encontrados"
          exit 1
      fi

  - type: Command
    name: "Modify application.properties"
    timeoutInSeconds: 60
    command: |
      if [ -f "src/main/resources/application.properties" ]; then
        echo "üîß Modifying application.properties..."
        sed -i 's|TNS_ADMIN=C:/Users/cesar/Wallet_TelegramBotDatabase|TNS_ADMIN=/wallet|g' src/main/resources/application.properties
        sed -i 's|oci.private-key-path=${OCI_PRIVATE_KEY_PATH:C:/Users/cesar/ObjectStorageKeys/a01281202@tec.mx_2025-03-22T10_08_12.916Z.pem}|oci.private-key-path=/oci-keys/oci-private-key.pem|g' src/main/resources/application.properties
        echo "‚úÖ application.properties modified"
      fi

  - type: Command
    name: "Build with Maven"
    timeoutInSeconds: 600
    command: |
      export JAVA_HOME=/opt/java17
      export PATH=$JAVA_HOME/bin:$PATH
      
      mvn clean package -DskipTests
      
      if [ ! -f "target/FileService-0.0.1-SNAPSHOT.jar" ]; then
        echo "‚ùå JAR file not found!"
        exit 1
      fi
      
      echo "‚úÖ Maven build successful!"

  - type: Command
    name: "Prepare Docker build"
    timeoutInSeconds: 120
    command: |
      mkdir -p build build/wallet build/oci-keys
      
      cp target/FileService-0.0.1-SNAPSHOT.jar build/
      cp -r wallet/* build/wallet/ 2>/dev/null || true
      cp -r oci-keys/* build/oci-keys/ 2>/dev/null || true
      
      cat > Dockerfile << 'EOF'
      FROM container-registry.oracle.com/graalvm/jdk:17
      
      WORKDIR /app
      
      RUN mkdir -p /wallet /oci-keys
      
      COPY build/FileService-0.0.1-SNAPSHOT.jar /app/app.jar
      COPY build/wallet/ /wallet/
      COPY build/oci-keys/ /oci-keys/
      
      RUN chmod 755 /app/app.jar
      RUN chmod 600 /wallet/* /oci-keys/* 2>/dev/null || true
      
      ENV TNS_ADMIN=/wallet
      ENV ORACLE_HOME=/wallet
      ENV LD_LIBRARY_PATH=/wallet
      ENV OCI_PRIVATE_KEY_PATH=/oci-keys/oci-private-key.pem
      
      RUN echo "=== WALLET SSO-ONLY DEBUG ===" && ls -la /wallet/ && echo "=== CWALLET.SSO CHECK ===" && if [ -f "/wallet/cwallet.sso" ]; then echo "cwallet.sso size: $(wc -c < /wallet/cwallet.sso) bytes"; else echo "cwallet.sso NOT FOUND"; fi && echo "=== SQLNET.ORA CONTENT ===" && cat /wallet/sqlnet.ora
      
      EXPOSE 8082
      
      ENTRYPOINT ["java", "-Djava.security.egd=file:/dev/./urandom", "-Doracle.net.wallet_location=/wallet", "-Doracle.net.tns_admin=/wallet", "-jar", "/app/app.jar"]
      EOF

  - type: Command
    name: "Build and Push Docker image"
    timeoutInSeconds: 900
    command: |
      VERSION="$(date +'%Y%m%d-%H%M%S')"
      if [ -d ".git" ]; then
        COMMIT_SHORT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        VERSION="${VERSION}-${COMMIT_SHORT}"
      fi
      
      IMAGE_TAG="${REGISTRY}/${NAMESPACE}/${REPOSITORY}/${IMAGE_NAME}:${VERSION}"
      
      # Obtener auth token
      AUTH_TOKEN=$(oci secrets secret-bundle get --secret-id "$AUTH_TOKEN_OCID" --stage LATEST --query 'data."secret-bundle-content".content' --raw-output 2>/dev/null)
      DECODED_TOKEN=$(echo "$AUTH_TOKEN" | base64 -d 2>/dev/null)
      if [ $? -eq 0 ] && [ ! -z "$DECODED_TOKEN" ]; then
        AUTH_TOKEN="$DECODED_TOKEN"
      fi
      
      DOCKER_USERNAME="${NAMESPACE}/a01281202@tec.mx"
      
      echo "${AUTH_TOKEN}" | docker login ${REGISTRY} -u "${DOCKER_USERNAME}" --password-stdin
      
      docker build --no-cache -t "${IMAGE_TAG}" .
      
      export IMAGE_FULL_NAME="${IMAGE_TAG}"
      export VERSION="${VERSION}"

outputArtifacts:
  - name: file-service-image
    type: DOCKER_IMAGE
    location: ${IMAGE_FULL_NAME}